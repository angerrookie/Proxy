代理模式：
    定义：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。
    代理模式是一种设计模式，简单说即是在不改变源码的情况下，实现对目标对象的功能扩展。
代理模式包含如下角色：
    ISubject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。
    RealSubject：真实主题角色，是实现抽象主题接口的类。
    Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。
代理模式的特点：两个子类共同实现一个接口，其中一个子类负责真实业务实现，另一个子类完成辅助真实业务主题的操作。
静态代理、动态代理（JDK动态代理、cglib动态代理）

    静态代理：由程序员编写的代理类，并在程序运行前就编译好的，而不是由程序动态产生代理类，这就是所谓的静态。

    两种实现方式：聚合（代理类和被代理类实现同一个接口）、继承（代理类继承被代理类：不够灵活）

    动态代理： 代理类在程序运行时创建的代理方式被成为动态代理。。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。
        JDK动态代理
            代理步骤：
                （1）定义一个事件管理器类实现invocationHandle接口,并重写invoke（代理类，被代理的方法，方法的参数列表）方法。
                （2）实现被代理类及其实现的接口，
                （3）调用Proxy.newProxyInstance(类加载器，类实现的接口，事务处理器对象);生成一个代理实例。
                （4）通过该代理实例调用方法。
            因为Java只允许单继承，而JDK生成的代理类本身就继承了Proxy类，因此，使用JDK实现的动态代理不能完成继承式的动态代理，但是我们可以使用cglib来实现继承式的动态代理。
                1、真实业务类
                2、实现MethodInterceptorjiek的动态代理类
            动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样对每一个方法或方法组合进行处理。